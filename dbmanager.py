import sqlite3
import json
import os
from typing import TypeVar, List, Tuple, Union


_iorder = int
_modid = int
_modver = str
_moddir = str
_modname = str
_modenabled = int

DBRow = Tuple[_iorder,
              _modid,
              _modver,
              _moddir,
              _modname,
              _modenabled
             ]


class DBManager:

    _SCHEMA = """CREATE TABLE mods (
            iorder    INTEGER primary key,
            modid     INTEGER,
            version   TEXT,
            directory TEXT    unique,
            name      TEXT,
            enabled   INTEGER default 1
        )"""

    __fields = ["modid", "version", "directory", "name", "enabled"]

    def __init__(self):
        # create db in memory
        self._con = sqlite3.connect(":memory:")

        # create the mods table
        # NOTE: `iorder` (i.e. the mod "install-order") is not
        # stored on disk with the rest of the mod info; it is
        # instead inferred from the order in which the mods
        # are listed in the config file and the number auto-
        # generated by sqlite
        # NOTE2: `directory` is the name of the folder in the
        # mods-directory where the files for this mod are saved.
        # `name` is initially equivalent, but can be changed as
        # desired by the user.
        self._con.execute(self._SCHEMA)

    @property
    def conn(self) -> sqlite3.Connection:
        """
        Directly access the database connection of this manager
        in order to perform custom queries.
        :return:
        """
        return self._con

    @property
    def mods(self) -> List[DBRow]:
        """
        Return list of all mods from the mod db
        :return:
        """
        return self.getModInfo()


    # convenience methods
    def enabledMods(self, name_only = False):
        """
        Fetches all mods from the mod database that are
        marked as enabled.
        :param name_only: Return only the names of the mods
        :return:
        """
        if name_only:
            return [ t[0] for t in self._con.execute("select name from mods where enabled = 1")]
        return self._con.execute("select * from mods where enabled = 1").fetchall()

    def disabledMods(self, name_only = False):
        """
        Fetches all mods from the mod database that are
        marked as disabled.
        :param name_only: Return only the names of the mods
        :return:
        """
        if name_only:
            return [ t[0] for t in self._con.execute("select name from mods where enabled = 0")]
        return self._con.execute("select * from mods where enabled = 0").fetchall()

    def getModInfo(self, raw_cursor = False) -> Union[List[DBRow], sqlite3.Cursor]:
        """
        Returns all information about installed mods as a list
        of tuples.
        :param raw_cursor: If true, return the db cursor object instead of a list.
        :return:  Tuple of mod info or sqlite3.cursor
        """
        cur = self._con.execute("select * from mods")
        if raw_cursor:
            return cur
        return cur.fetchall()

    def shutdown(self):
        """
        Close the db connection
        :return:
        """
        self._con.close()


    def loadModDB(self, json_source):
        """
        read the saved mod information from a json file and
        populate the in-memory database
        :param json_source: path to saved info in json format
        """
        with open(json_source, 'r') as f:
            # read from json file and convert mappings
            # to ordered tuples for sending to sqlite
            mods = json.load(f, object_pairs_hook=self.toRowTuple)

            with self._con:
                # insert the list of row-tuples into the in-memory db
                self._con.executemany("INSERT INTO mods(modid, version, directory, name, enabled) VALUES (?, ?, ?, ?, ?)", mods)


    def saveModDB(self, json_target):
        """
        Write the data from the in-memory database to a
        json file on disk. The file will be overwritten, or
        created if it does not exist
        :param json_target:
        :return:
        """
        modinfo = []
        for row in self._con.execute("SELECT * FROM mods"):
            order, modid, ver, mdir, name, enabled = row

            modinfo.append({
                "modid": modid,
                "version": ver,
                "directory": mdir,
                "name": name,
                "enabled": enabled
            })

        with open(json_target, "w") as f:
            json.dump(modinfo, f, indent=1)

    @staticmethod
    def toRowTuple(pairs):
        """
        Used as object_pair_hook for json.load(). Takes the mod
        information loaded from the json file and converts it
        to a tuple containing just the field values in the
        correct order for feeding to the sqlite database.
        :param pairs:
        :return:
        """

        d = dict(pairs)

        return tuple(d[DBManager.__fields[i]] for i in range(len(DBManager.__fields)))




def test():

    from skymodman_main import ModManager
    testdb = "res/test.db"

    if not os.path.exists(testdb):
        MM = ModManager()
        con = sqlite3.connect(testdb)
        con.execute("CREATE TABLE mods (id INTEGER primary key, modid INTEGER, version VARCHAR, name VARCHAR unique, enabled INTEGER)")

        mods = []
        for m in MM.installed_mods:
            if m[0] in MM.mod_states["Active"]:
                mods.append(m + (1, ))
            else:
                mods.append(m + (0, ))

        with con:
            con.executemany("INSERT INTO mods(name, modid, version, enabled) VALUES (?, ?, ?, ?)", mods)
    else:
        con = sqlite3.connect(testdb)


    modinfo = []
    for row in con.execute("SELECT * FROM mods"):
        order, mid, ver, name, active = row

        modinfo.append({
            "id": mid,
            "directory": name,
            "name": name,
            "version": ver,
            "enabled": active
        })

    con.close()

    # dumping info as a list allows keeping the
    # correct order when reloading without having
    # to store the order index
    with open("res/modinfo.json",'w') as f:
        json.dump(modinfo, f, indent=1)



    # print(mods)
# from pprint import pprint

__fields = ["id", "version", "directory", "name", "enabled"]

def toRowTuple(pairs):
    """
    Used as object_pair_hook for json.load(). Takes the mod
    information loaded from the json file and converts it
    to a tuple containing just the field values in the
    correct order for feeding to the sqlite database.
    :param pairs:
    :return:
    """

    d = dict(pairs)

    return tuple(d[__fields[i]] for i in range(len(__fields)))

def loadDB(jsonfile: str) -> sqlite3.Connection:
    # create db in memory
    con = sqlite3.connect(":memory:")

    # create the mods table
    # NOTE: `iorder` (i.e. the mod "install-order") is not
    # stored on disk with the rest of the mod info; it is
    # instead inferred from the order in which the mods
    # are listed in the config file and the number auto-
    # generated by sqlite
    # NOTE2: `directory` is the name of the folder in the
    # mods-directory where the files for this mod are saved.
    # `name` is initially equivalent, but can be changed as
    # desired by the user.
    con.execute("CREATE TABLE mods (iorder INTEGER primary key, modid INTEGER, version TEXT, directory TEXT unique, name TEXT, enabled INTEGER)")

    with open(jsonfile, 'r') as f:
        # read from json file and convert mappings
        # to ordered tuples for sending to sqlite
        mods = json.load(f, object_pairs_hook=toRowTuple)

    with con:
        # insert the list of row-tuples into the in-memory db
        con.executemany("INSERT INTO mods(modid, version, directory, name, enabled) VALUES (?, ?, ?, ?, ?)", mods)

    return con

def testload():

    # con = loadDB("res/modinfo.json")

    DB = DBManager()

    # check
    # for row in con.execute("SELECT iorder, name FROM mods WHERE enabled = 0"):
    #     print(row)

    DB.loadModDB("res/modinfo.json")

    # [print(r) for r in DB.mods]
    [print(r) for r in DB.enabledMods(True)]
    # [print(r) for r in DB.disabledMods(True)]

    # print(DB.disabledMods(True))

    # close db
    # con.close()
    DB.shutdown()

if __name__ == '__main__':
    # test()
    testload()